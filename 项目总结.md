# 思路
## 一般多线程存在限制

线程的开辟和回收都消耗较大，包括用户空间和内核空间之间的上下文切换，资源分配等，反复申请和结束内存会带来很高性能代价。因此使用线程池，提前申请一定数量线程，为任务分配线程并执行任务，完成后也不回收线程，而是放回池中准备执行下个任务。

线程本身也占用大量资源，这使得开辟大量线程消耗过多内存，无法执行实际任务。因此同时存在的线程数量也应受到限制。

## 线程池模式

线程池可创建为固定线程数量的fixed模式和允许在固定线程数基础上动态创建线程的cached模式。

# 设计

## 抉择1：如何实现Task的多态？

Task是一个可用于执行的任务，至少应包含一个函数，可由用户自定义执行内容，有两种多态方案：

- 线程池库提供Task基类，用户继承该基类，重写其中特定方法（如run()），线程池可以通过调用基类的该方法执行子类的任务（虚函数）。
- 模板多态，将任务提交函数（submitTask）设计为模板函数，用户可直接传入不同函数作为待执行任务。

第一个方案实现较为简单

第二个方案的优势在于可以通过可变参数模板实现为任务配备各式各样的参数列表

本质上都是调用std::thread开启线程，并在其中调用对应函数执行任务，因此如果编写足够细致，都能避免不必要的拷贝构造，性能上不会有太大差异。

## 抉择2：如何设计线程回收？

抉择的点在于析构线程池/主动停止线程池时的行为应该是怎样的？

- 尽快结束线程
- 执行完任务队列中所有任务后退出

两者的差异只在于workThread中退出条件的位置和while循环的退出条件，两种方案实现比较简单，以及在第二种方案中应让停止信号发送后不再允许添加任务，可能造成用户迷惑。

## 抉择3：如何获取返回值

- 自定义Result
- 使用std::future

两种原理类似，前者在c++版本较低时使用
